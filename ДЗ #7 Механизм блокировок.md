## Домашнее задание "Механизм блокировок"
***Цель: понимать как работает механизм блокировок объектов и строк***

### Описание/Пошаговая инструкция выполнения домашнего задания:

####  Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
ssh user@130.193.41.150
sudo -u postgres psql

***Сбросим параметры с предыдущего занятия***
ALTER SYSTEM RESET ALL;

select pg_reload_conf();

***Создадим базу для тестирования***

create database db_locks;

\c db_locks;
You are now connected to database "db_locks" as user "postgres".

CREATE TABLE test_locks (id serial, descr text);

INSERT INTO test_locks(descr) SELECT md5(RANDOM()::TEXT) FROM generate_series(1,100);

select count(*) from test_locks;
>100

***Установим параметр, к-й записывает в журнал продолжительность выполнения всех команд, время работы которых не меньше указанного***

--alter system set log_min_duration_statement = 200;
--show log_min_duration_statement;

alter system set log_lock_waits = on;

SELECT pg_reload_conf();


db_locks=# show log_lock_waits;
>on

***Воспроизведем блокировку с помощью Update:***

BEGIN TRANSACTION;

db_locks=*# UPDATE test_locks SET descr = ' test 2'  WHERE id = 2;

select * from test_locks where id = 2;

________________
| id | descr |
------------
| 2 |  test 2 |
-------------

  
***Во втором окне выполним ту же операцию Update с тем же полем:***
db_locks=# BEGIN TRANSACTION;

db_locks=# UPDATE test_locks SET descr = ' test 2.2'  WHERE id = 2;

***В первом окне делаем***
db_locks=*# commit;

***Во втором окне блокировка пропала и транзакция также завершается:***

db_locks=# UPDATE test_locks SET descr = ' test 2.2'  WHERE id = 2;

COMMIT

\q
db_locks=# select * from test_locks where id = 2;
________________
| id | descr |
------------
| 2 |  test 2.2 |
-------------

***Проверим лог из журнала на предмет появления в нем записи блокировки:***


user@postgres:~$ sudo tail -n 3 /var/log/postgresql/postgresql-14-main.log

2023-03-19 17:02:26.012 UTC [1267] postgres@db_locks CONTEXT:  while updating tuple (0,2) in relation "test_locks"
2023-03-19 17:02:26.012 UTC [1267] postgres@db_locks STATEMENT:  UPDATE test_locks SET descr = ' test 2.2'  WHERE id = 2

=> в журнал попала транзакция №2, которая ожидала блокировку.

#### Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

\c db_locks

db_locks=# alter system set deadlock_timeout = 200;

db_locks=# SELECT pg_reload_conf();

db_locks=# show deadlock_timeout;
>200ms
 

***Определим pid для каждой из 3-х сессий:***

SELECT pg_backend_pid();

- 1 -1571
- 2 -1967
- 3 -2031


***Посмотрим, какие данные хранятся в pg_locks до начала теста (1):***

db_locks=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 1571;

  locktype  | relation | virtxid | xid |      mode       | granted
------------+----------+---------+-----+-----------------+---------
 relation   | pg_locks |         |     | AccessShareLock | t
 virtualxid |          | 4/46    |     | ExclusiveLock   | t

***В нашем случае мы видим следующие блокировки:***
- на команду pg_locks в режиме AccessShareLock - просмотр статистики через SELECT
- блокировка типа virtualxid (ExclusiveLock) - блокировка номера собственной транзакции 


***Начнем одну и ту же транзакцию в каждом окне:***

db_locks=# BEGIN TRANSACTION;

 - (1) db_locks=*# UPDATE test_locks SET descr = ' test 1.1'  WHERE id = 1;
 - (2) db_locks=*# UPDATE test_locks SET descr = ' test 1.2'  WHERE id = 1;
 - (3) db_locks=*# UPDATE test_locks SET descr = ' test 1.3'  WHERE id = 1;

=> В первом окне (1) транзакция выполнится, а в двух других сессиях будет блокировка


***Проверим информацию о блокировках по всем 3 pid:***

db_locks=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 1571;

   locktype    |  relation  | virtxid |   xid   |       mode       | granted
---------------+------------+---------+---------+------------------+---------
 relation      | test_locks |         |         | RowExclusiveLock | t
 virtualxid    |            | 4/47    |         | ExclusiveLock    | t
 transactionid |            |         | 2936965 | ExclusiveLock    | t
 
 ***Дополнительно наблюдаем :***

|relation      | accounts |         |     | RowExclusiveLock | t| - означает, что в данный момент мы выполнили блокировку на таблицу test_locks в режиме RowExclusiveLock, который как раз соответствует нашей операции UPDATE. 
Параметр t означает, что блокировка успешно прошла.
|transactionid |          |         | 2936965  | ExclusiveLock    | t| - исключительная блокировка транзакции 2936965 , которая появилась, как только транзакция начала изменять данные.

***Проверим блокировки pid второго окна:***

db_locks=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 1967;

   locktype    |  relation  | virtxid |   xid   |       mode       | granted
---------------+------------+---------+---------+------------------+---------
 relation      | test_locks |         |         | RowExclusiveLock | t
 virtualxid    |            | 5/117   |         | ExclusiveLock    | t
 transactionid |            |         | 2936966 | ExclusiveLock    | t
 transactionid |            |         | 2936965 | ShareLock        | f
 tuple         | test_locks |         |         | ExclusiveLock    | t
 
=> Мы видим, что по сравнению с информацией о блокировках в рамках собственного pid, для pid из второго окна появились дополнительные типы:***

|transactionid |          |         | 2936966 | ExclusiveLock    | t| - запрос на блокировку для выполнения транзакции UPDATE;

|transactionid |          |         | 2936965 | ShareLock        | f| - указывает на то, что блокировка на транзакцию не может быть выполнена, так как в данный момент это поле уже заблокировано другой транзакцией с xid 2936965. Это транзакция из перовго окна, которая выполняет UPDATE;

|tuple         | accounts |         |     | ExclusiveLock    | t| - говорит о том, что был создан tuple для ожидания завершения транзакции, которая сейчас блокирует строку. Это говорит о том, что данная транзакция стоит первой в очереди.
И теперь посмотрим блокировки нашей третьей сесси:

locks=*# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted
FROM pg_locks WHERE pid = 15867;
   locktype    | relation | virtxid | xid |       mode       | granted
---------------+----------+---------+-----+------------------+---------
 relation      | accounts |         |     | RowExclusiveLock | t
 virtualxid    |          | 6/4     |     | ExclusiveLock    | t
 transactionid |          |         | 497 | ExclusiveLock    | t
 tuple         | accounts |         |     | ExclusiveLock    | f
(4 rows)

db_locks=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 2031;
   locktype    |  relation  | virtxid |   xid   |       mode       | granted
---------------+------------+---------+---------+------------------+---------
 relation      | test_locks |         |         | RowExclusiveLock | t
 virtualxid    |            | 7/21    |         | ExclusiveLock    | t
 transactionid |            |         | 2936967 | ExclusiveLock    | t
 tuple         | test_locks |         |         | ExclusiveLock    | f


Новых типов блокировок нет, только изменение уже описанных ранее:

|relation      | accounts |         |     | RowExclusiveLock | t| - блокировка на таблицу accounts;
|transactionid |          |         | 497 | ExclusiveLock    | t| - новая транзакция на UPDATE;
|tuple         | accounts |         |     | ExclusiveLock    | f| - в данном случае не было изменения tuple, так как tuple была ранее создана в сессии 2. Поэтому, наш запрос просто стал в очередь на исполнение.




роверим очередь на выполнение транзакций:

db_locks=# SELECT locktype, mode, granted, pid, pg_blocking_pids(pid) AS wait_for FROM pg_locks WHERE relation = 'test_locks'::regclass;
 locktype |       mode       | granted | pid  | wait_for
----------+------------------+---------+------+----------
 relation | RowExclusiveLock | t       | 1967 | {1571}
 relation | RowExclusiveLock | t       | 1571 | {}
 relation | RowExclusiveLock | t       | 2031 | {1967}
 tuple    | ExclusiveLock    | f       | 2031 | {1967}
 tuple    | ExclusiveLock    | t       | 1967 | {1571}
 
Из этого всего видно, что для выполнения операции с pid 14412 (вторая сессия) необходимо дождаться выполнения pid 14393 (сессия 1), а для pid 15867 (третья сессия) необходимо дождаться выполнения 14412 (вторая).


#### Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?


#### Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY5MDk1ODY0NCwtMTE0NzYyNDAxNyw0MT
k1OTMzOSw3ODE2MDA1OTMsLTYyNDIwMDU3NywyMjMxNjcxNjgs
MTQ2NDMwMzg1MV19
-->