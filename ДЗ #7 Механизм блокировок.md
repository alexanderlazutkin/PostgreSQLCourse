## Домашнее задание "Механизм блокировок"
***Цель: понимать как работает механизм блокировок объектов и строк***

### Описание/Пошаговая инструкция выполнения домашнего задания:

####  Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
ssh user@130.193.41.150
sudo -u postgres psql

***Сбросим параметры с предыдущего занятия***
ALTER SYSTEM RESET ALL;

select pg_reload_conf();

***Создадим базу для тестирования***

create database db_locks;

\c db_locks;
You are now connected to database "db_locks" as user "postgres".

CREATE TABLE test_locks (id serial, descr text);

INSERT INTO test_locks(descr) SELECT md5(RANDOM()::TEXT) FROM generate_series(1,100);

select count(*) from test_locks;
>100

***Установим параметр, к-й записывает в журнал продолжительность выполнения всех команд, время работы которых не меньше указанного***

--alter system set log_min_duration_statement = 200;
--show log_min_duration_statement;

alter system set log_lock_waits = on;

SELECT pg_reload_conf();


db_locks=# show log_lock_waits;
>on

***Воспроизведем блокировку с помощью Update:***

BEGIN TRANSACTION;

db_locks=*# UPDATE test_locks SET descr = ' test 2'  WHERE id = 2;

select * from test_locks where id = 2;

________________
| id | descr |
------------
| 2 |  test 2 |
-------------

  
***Во втором окне выполним ту же операцию Update с тем же полем:***
db_locks=# BEGIN TRANSACTION;

db_locks=# UPDATE test_locks SET descr = ' test 2.2'  WHERE id = 2;

***В первом окне делаем***
db_locks=*# commit;

***Во втором окне блокировка пропала и транзакция также завершается:***

db_locks=# UPDATE test_locks SET descr = ' test 2.2'  WHERE id = 2;

COMMIT

\q
db_locks=# select * from test_locks where id = 2;
________________
| id | descr |
------------
| 2 |  test 2.2 |
-------------

***Проверим лог из журнала на предмет появления в нем записи блокировки:***


user@postgres:~$ sudo tail -n 3 /var/log/postgresql/postgresql-14-main.log

2023-03-19 17:02:26.012 UTC [1267] postgres@db_locks CONTEXT:  while updating tuple (0,2) in relation "test_locks"
2023-03-19 17:02:26.012 UTC [1267] postgres@db_locks STATEMENT:  UPDATE test_locks SET descr = ' test 2.2'  WHERE id = 2

=> в журнал попала транзакция №2, которая ожидала блокировку.

#### Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.


#### Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?


#### Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExNDc2MjQwMTcsNDE5NTkzMzksNzgxNj
AwNTkzLC02MjQyMDA1NzcsMjIzMTY3MTY4LDE0NjQzMDM4NTFd
fQ==
-->